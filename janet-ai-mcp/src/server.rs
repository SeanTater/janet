use crate::ServerConfig;
use anyhow::Result;
use rmcp::{ServerHandler, ServiceExt, model::ServerInfo, schemars, tool};
use serde::Deserialize;
use tokio::io::{stdin, stdout};
use tracing::info;

// Request structs for tool parameters
#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct RegexSearchRequest {
    #[schemars(description = "Regular expression pattern to search for")]
    pub pattern: String,
    #[schemars(description = "File type filter (e.g., 'rs', 'toml', 'md'). Optional.")]
    pub file_type: Option<String>,
    #[schemars(description = "Include dependency files (in gitignore)")]
    pub include_deps: Option<bool>,
    #[schemars(description = "Include autogenerated docs (target/doc)")]
    pub include_docs: Option<bool>,
}

#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct SemanticSearchRequest {
    #[schemars(description = "Query text for semantic search")]
    pub query: String,
    #[schemars(description = "Maximum number of results to return")]
    pub limit: Option<u32>,
    #[schemars(description = "Similarity threshold (0.0 to 1.0)")]
    pub threshold: Option<f32>,
}

#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct DelegateSearchRequest {
    #[schemars(description = "Query for embedding search")]
    pub embedding_query: String,
    #[schemars(description = "Query for LLM validation/refinement")]
    pub llm_query: Option<String>,
    #[schemars(description = "Number of candidates to validate")]
    pub candidates: Option<u32>,
}

/// Janet MCP Server that provides search capabilities across codebases
#[derive(Debug, Clone)]
pub struct JanetMcpServer {
    #[allow(dead_code)] // Used in tool implementations, will be used more in future integration
    config: ServerConfig,
}

impl JanetMcpServer {
    /// Create a new Janet MCP server with the given configuration
    pub async fn new(config: ServerConfig) -> Result<Self> {
        info!(
            "Initializing Janet MCP server with root: {:?}",
            config.root_dir
        );

        Ok(Self { config })
    }

    /// Status tool - show index statistics and provider info
    #[tool(
        description = "Show index statistics including file count, chunk count, queue backlog, and provider implementations"
    )]
    async fn status(&self) -> String {
        info!("Processing status request");

        // TODO: Integrate with janet-ai-retriever to get actual statistics
        format!(
            "Janet AI MCP Server Status\n\
            Root Directory: {:?}\n\
            Semantic Search: {}\n\
            Delegate Search: {}\n\
            \n\
            File Index: 0 files indexed\n\
            Chunk Database: 0 chunks available\n\
            Queue Backlog: 0 pending operations\n\
            \n\
            Available Providers:\n\
            - Embedding Provider: {} (planned)\n\
            - Storage Provider: SQLite (planned)\n\
            ",
            self.config.root_dir,
            if self.config.enable_semantic_search {
                "enabled"
            } else {
                "disabled"
            },
            if self.config.enable_delegate_search {
                "enabled"
            } else {
                "disabled"
            },
            if self.config.enable_semantic_search {
                "fastembed"
            } else {
                "none"
            }
        )
    }

    /// Regex search tool - search project files, dependencies, and docs
    #[tool(
        description = "Search files using regex patterns across project files, dependencies, and autogenerated docs"
    )]
    async fn regex_search(&self, request: RegexSearchRequest) -> String {
        info!(
            "Processing regex search: pattern='{}', file_type={:?}",
            request.pattern, request.file_type
        );

        // TODO: Implement actual regex search using janet-ai-retriever
        format!(
            "Regex Search Results\n\
            Pattern: '{}'\n\
            File Type Filter: {:?}\n\
            Include Dependencies: {}\n\
            Include Documentation: {}\n\
            \n\
            No results found (implementation pending)\n\
            ",
            request.pattern,
            request.file_type,
            request.include_deps.unwrap_or(false),
            request.include_docs.unwrap_or(false)
        )
    }

    /// Semantic search tool - search using embeddings
    #[tool(description = "Search files using semantic similarity with embeddings")]
    async fn semantic_search(&self, request: SemanticSearchRequest) -> Result<String, String> {
        if !self.config.enable_semantic_search {
            return Err(
                "Semantic search is disabled. Enable with --enable-semantic flag.".to_string(),
            );
        }

        info!(
            "Processing semantic search: query='{}', limit={:?}, threshold={:?}",
            request.query, request.limit, request.threshold
        );

        // TODO: Implement semantic search using janet-ai-embed
        Ok(format!(
            "Semantic Search Results\n\
            Query: '{}'\n\
            Limit: {}\n\
            Threshold: {:.2}\n\
            \n\
            No results found (implementation pending)\n\
            ",
            request.query,
            request.limit.unwrap_or(10),
            request.threshold.unwrap_or(0.7)
        ))
    }

    /// Delegate search tool - semantic search with LLM validation
    #[tool(
        description = "Advanced search using semantic similarity followed by LLM validation for complex queries"
    )]
    async fn delegate_search(&self, request: DelegateSearchRequest) -> Result<String, String> {
        if !self.config.enable_delegate_search {
            return Err(
                "Delegate search is disabled. Enable with --enable-delegate flag.".to_string(),
            );
        }

        info!(
            "Processing delegate search: embedding_query='{}', llm_query={:?}",
            request.embedding_query, request.llm_query
        );

        // TODO: Implement delegate search with LLM validation
        Ok(format!(
            "Delegate Search Results\n\
            Embedding Query: '{}'\n\
            LLM Query: '{}'\n\
            Candidates: {}\n\
            \n\
            No results found (implementation pending)\n\
            ",
            request.embedding_query,
            request
                .llm_query
                .as_deref()
                .unwrap_or("(same as embedding query)"),
            request.candidates.unwrap_or(10)
        ))
    }

    /// Serve the MCP server using stdio transport
    pub async fn serve_stdio(&self) -> Result<()> {
        info!("Starting MCP server with stdio transport");

        let transport = (stdin(), stdout());
        let server = self.clone().serve(transport).await?;
        let quit_reason = server.waiting().await?;

        info!("MCP server quit: {:?}", quit_reason);
        Ok(())
    }
}

impl ServerHandler for JanetMcpServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            instructions: Some("Janet AI MCP Server - provides semantic and regex search capabilities across codebases".into()),
            ..Default::default()
        }
    }
}
