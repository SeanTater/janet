use std::sync::Arc;

use crate::ServerConfig;
use crate::tools::{
    self, regex_search::RegexSearchRequest, semantic_search::SemanticSearchRequest,
};
use anyhow::Result;
use janet_ai_retriever::{
    retrieval::{
        enhanced_index::EnhancedFileIndex,
        indexing_engine::{IndexingEngine, IndexingEngineConfig},
    },
    status::StatusApi,
};
use rmcp::handler::server::tool::Parameters;
use rmcp::model::{Implementation, ProtocolVersion, ServerCapabilities};
use rmcp::tool_handler;
use rmcp::{
    ErrorData as McpError, ServerHandler, ServiceExt,
    handler::server::tool::ToolRouter,
    model::{CallToolResult, Content, ServerInfo},
};
use tokio::io::{stdin, stdout};
use tokio::sync::Mutex;
use tracing::info;

/// Janet MCP Server that provides search capabilities across codebases
#[derive(Clone)]
pub struct JanetMcpServer {
    config: ServerConfig,
    #[allow(dead_code)]
    enhanced_index: EnhancedFileIndex,
    #[allow(dead_code)]
    indexing_engine: Arc<Mutex<IndexingEngine>>,
    indexing_config: IndexingEngineConfig,
    tool_router: ToolRouter<Self>,
}

#[rmcp::tool_router]
impl JanetMcpServer {
    /// Create a new Janet MCP server with the given configuration
    pub async fn new(config: ServerConfig) -> Result<Self> {
        info!(
            "Initializing Janet MCP server with root: {:?}",
            config.root_dir
        );

        use janet_ai_retriever::retrieval::indexing_mode::IndexingMode;

        // Create enhanced index
        let enhanced_index = EnhancedFileIndex::open(&config.root_dir).await?;

        // Create indexing configuration
        let indexing_config =
            IndexingEngineConfig::new("local".to_string(), config.root_dir.clone())
                .with_mode(IndexingMode::ReadOnly)
                .with_max_workers(4);

        // Create indexing engine
        let indexing_engine = IndexingEngine::new(indexing_config.clone()).await?;

        Ok(Self {
            config,
            enhanced_index,
            indexing_engine: Arc::new(Mutex::new(indexing_engine)),
            indexing_config,
            tool_router: Self::tool_router(),
        })
    }

    /// Status tool - comprehensive system status and debugging information
    #[rmcp::tool(
        description = "Show comprehensive system status including index health, configuration, performance metrics, and troubleshooting information"
    )]
    async fn status(&self) -> Result<CallToolResult, McpError> {
        info!("Processing comprehensive status request");

        let mut status = format!(
            "Janet AI MCP Server Status\n\
            ================================\n\
            Server Version: {}\n\
            Root Directory: {:?}\n\
            Working Directory: {:?}\n\n",
            env!("CARGO_PKG_VERSION"),
            self.config.root_dir,
            std::env::current_dir().unwrap_or_else(|_| "<unknown>".into())
        );

        // Use comprehensive diagnostic APIs if available
        let indexing_engine = self.indexing_engine.lock().await;
        status.push_str(&self.get_comprehensive_status(&self.enhanced_index, &indexing_engine, &self.indexing_config).await);

        Ok(CallToolResult::success(vec![Content::text(status)]))
    }

    /// Get comprehensive status using all diagnostic APIs
    async fn get_comprehensive_status(
        &self,
        enhanced_index: &EnhancedFileIndex,
        indexing_engine: &IndexingEngine,
        indexing_config: &IndexingEngineConfig,
    ) -> String {
        match StatusApi::get_comprehensive_status(
            enhanced_index,
            indexing_engine,
            indexing_config,
            &self.config.root_dir,
        )
        .await
        {
            Ok(status) => match status.to_toml() {
                Ok(toml_output) => toml_output,
                Err(e) => format!("⚠ Failed to serialize status to TOML: {}", e),
            },
            Err(e) => format!("⚠ Failed to get comprehensive status: {}", e),
        }
    }

    /// Regex search tool - search project files, dependencies, and docs
    #[rmcp::tool(
        description = "Search files using regex patterns across project files, dependencies, and autogenerated docs"
    )]
    async fn regex_search(
        &self,
        Parameters(request): Parameters<RegexSearchRequest>,
    ) -> Result<CallToolResult, McpError> {
        match tools::regex_search::regex_search(&self.config, request).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(result)])),
            Err(err) => Err(McpError::internal_error(err, None)),
        }
    }

    /// Semantic search tool - search using embeddings
    #[rmcp::tool(description = "Search files using semantic similarity with embeddings")]
    async fn semantic_search(
        &self,
        Parameters(request): Parameters<SemanticSearchRequest>,
    ) -> Result<CallToolResult, McpError> {
        match tools::semantic_search::semantic_search(&self.config, request).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(result)])),
            Err(err) => Err(McpError::internal_error(err, None)),
        }
    }

    /// Serve the MCP server using stdio transport
    pub async fn serve_stdio(&self) -> Result<()> {
        info!("Starting MCP server with stdio transport");

        let transport = (stdin(), stdout());
        let server = self.clone().serve(transport).await?;
        let quit_reason = server.waiting().await?;

        info!("MCP server quit: {:?}", quit_reason);
        Ok(())
    }
}

#[tool_handler]
impl ServerHandler for JanetMcpServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::LATEST,
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation::from_build_env(),
            instructions: Some("Janet AI MCP Server - provides regex and semantic search capabilities across codebases".into()),
        }
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[tokio::test]
    async fn test_server_creation() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");
        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        let server = JanetMcpServer::new(config).await;
        assert!(server.is_ok(), "Server creation should succeed");
    }

    #[tokio::test]
    async fn test_initialize_retriever_components_creates_database() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");
        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        let db_path = temp_dir.path().join(".janet-ai.db");
        assert!(!db_path.exists(), "Database should not exist initially");

        // Should succeed and create database
        let result = JanetMcpServer::new(config).await;
        assert!(
            result.is_ok(),
            "Should succeed and create database if missing"
        );

        // Database should now exist
        assert!(db_path.exists(), "Database should be created");
    }
}
