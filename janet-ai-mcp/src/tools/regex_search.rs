use crate::ServerConfig;
use anyhow::Result;
use ignore::WalkBuilder;
use regex::Regex;
use rmcp::schemars;
use serde::Deserialize;
use std::path::Path;
use tokio::fs;
use tracing::{info, warn};

#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct RegexSearchRequest {
    #[schemars(description = "Regular expression pattern to search for")]
    pub pattern: String,
    #[schemars(
        description = "Glob patterns to filter files (e.g., '*.rs', '**/*.{js,ts}', 'src/**'). Optional."
    )]
    pub globs: Option<Vec<String>>,
    #[schemars(description = "Include dependency files (in gitignore)")]
    pub include_deps: Option<bool>,
    #[schemars(description = "Include autogenerated docs (target/doc)")]
    pub include_docs: Option<bool>,
}

pub async fn regex_search(
    config: &ServerConfig,
    request: RegexSearchRequest,
) -> Result<String, String> {
    info!(
        "Processing regex search: pattern='{}', globs={:?}",
        request.pattern, request.globs
    );

    // Compile regex pattern
    let regex = match Regex::new(&request.pattern) {
        Ok(r) => r,
        Err(e) => return Err(format!("Invalid regex pattern: {e}")),
    };

    // Compile glob patterns once
    let compiled_globs: Result<Vec<glob::Pattern>, String> = match &request.globs {
        Some(globs) => globs
            .iter()
            .map(|pattern| {
                glob::Pattern::new(pattern)
                    .map_err(|e| format!("Invalid glob pattern '{pattern}': {e}"))
            })
            .collect(),
        None => Ok(Vec::new()),
    };

    let compiled_globs = compiled_globs?;

    let include_deps = request.include_deps.unwrap_or(false);
    let include_docs = request.include_docs.unwrap_or(false);

    let mut results = Vec::new();
    let mut searched_files = 0;

    // Build walker with appropriate ignores
    let mut walker_builder = WalkBuilder::new(&config.root_dir);

    if !include_deps {
        // Use gitignore to exclude dependencies
        walker_builder.git_ignore(true);
    } else {
        walker_builder.git_ignore(false);
    }

    // Walk through files
    for entry in walker_builder.build() {
        match entry {
            Ok(entry) => {
                let path = entry.path();

                // Skip directories
                if !path.is_file() {
                    continue;
                }

                // Check if we should include this file based on filters
                if !include_docs && path.starts_with(config.root_dir.join("target/doc")) {
                    continue;
                }

                // Filter by glob patterns if specified
                if !compiled_globs.is_empty() && !matches_any_glob(path, &compiled_globs) {
                    continue;
                }

                searched_files += 1;

                // Read and search file content
                match fs::read_to_string(path).await {
                    Ok(content) => {
                        let mut line_num = 1;
                        for line in content.lines() {
                            if regex.is_match(line) {
                                let relative_path = path
                                    .strip_prefix(&config.root_dir)
                                    .unwrap_or(path)
                                    .to_string_lossy();

                                results.push(format!(
                                    "{}:{}:{}",
                                    relative_path,
                                    line_num,
                                    line.trim()
                                ));
                            }
                            line_num += 1;
                        }
                    }
                    Err(e) => {
                        // Skip files we can't read (binary files, etc.)
                        if results.len() < 3 {
                            // Only log first few errors
                            warn!("Failed to read file {:?}: {}", path, e);
                        }
                    }
                }

                // Limit to avoid overwhelming output
                if results.len() >= 100 {
                    break;
                }
            }
            Err(e) => {
                warn!("Error walking directory: {}", e);
            }
        }
    }

    let output = if results.is_empty() {
        format!(
            "Regex Search Results\n\
            Pattern: '{}'\n\
            Glob Filters: {:?}\n\
            Include Dependencies: {}\n\
            Include Documentation: {}\n\
            Files Searched: {}\n\
            \n\
            No matches found.\n\
            ",
            request.pattern, request.globs, include_deps, include_docs, searched_files
        )
    } else {
        let result_summary = if results.len() >= 100 {
            format!("Found {}+ matches (showing first 100):", results.len())
        } else {
            format!("Found {} matches:", results.len())
        };

        format!(
            "Regex Search Results\n\
            Pattern: '{}'\n\
            Glob Filters: {:?}\n\
            Include Dependencies: {}\n\
            Include Documentation: {}\n\
            Files Searched: {}\n\
            \n\
            {}\n\
            {}\n\
            ",
            request.pattern,
            request.globs,
            include_deps,
            include_docs,
            searched_files,
            result_summary,
            results.join("\n")
        )
    };

    Ok(output)
}

/// Check if a path matches any of the provided compiled glob patterns
fn matches_any_glob(path: &Path, compiled_globs: &[glob::Pattern]) -> bool {
    let path_str = path.to_string_lossy();

    for pattern in compiled_globs {
        if pattern.matches(&path_str) {
            return true;
        }

        // Also check just the filename
        if let Some(filename) = path.file_name() {
            if pattern.matches(&filename.to_string_lossy()) {
                return true;
            }
        }
    }

    false
}
