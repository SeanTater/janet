use crate::ServerConfig;
use anyhow::Result;
use ignore::WalkBuilder;
use regex::Regex;
use rmcp::schemars;
use serde::Deserialize;
use std::path::Path;
use tokio::fs;
use tracing::{info, warn};

#[allow(dead_code)] // Used by rmcp macro system
#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct RegexSearchRequest {
    #[schemars(description = "Regular expression pattern to search for")]
    pub pattern: String,
    #[schemars(
        description = "Glob patterns to filter files (e.g., '*.rs', '**/*.{js,ts}', 'src/**'). Optional."
    )]
    pub globs: Option<Vec<String>>,
    #[schemars(description = "Include dependency files (in gitignore)")]
    pub include_deps: Option<bool>,
    #[schemars(description = "Include autogenerated docs (target/doc)")]
    pub include_docs: Option<bool>,
}

#[allow(dead_code)] // Used by rmcp macro system
pub async fn regex_search(
    config: &ServerConfig,
    request: RegexSearchRequest,
) -> Result<String, String> {
    info!(
        "Processing regex search: pattern='{}', globs={:?}",
        request.pattern, request.globs
    );

    // Compile regex pattern
    let regex = match Regex::new(&request.pattern) {
        Ok(r) => r,
        Err(e) => return Err(format!("Invalid regex pattern: {e}")),
    };

    // Compile glob patterns once
    let compiled_globs: Result<Vec<glob::Pattern>, String> = match &request.globs {
        Some(globs) => globs
            .iter()
            .map(|pattern| {
                glob::Pattern::new(pattern)
                    .map_err(|e| format!("Invalid glob pattern '{pattern}': {e}"))
            })
            .collect(),
        None => Ok(Vec::new()),
    };

    let compiled_globs = compiled_globs?;

    let include_deps = request.include_deps.unwrap_or(false);
    let include_docs = request.include_docs.unwrap_or(false);

    let mut results = Vec::new();
    let mut searched_files = 0;

    // Build walker with appropriate ignores
    let mut walker_builder = WalkBuilder::new(&config.root_dir);

    if !include_deps {
        // Use gitignore to exclude dependencies
        walker_builder.git_ignore(true);
    } else {
        walker_builder.git_ignore(false);
    }

    // Walk through files
    for entry in walker_builder.build() {
        match entry {
            Ok(entry) => {
                let path = entry.path();

                // Skip directories
                if !path.is_file() {
                    continue;
                }

                // Check if we should include this file based on filters
                if !include_docs && path.starts_with(config.root_dir.join("target/doc")) {
                    continue;
                }

                // Filter by glob patterns if specified
                if !compiled_globs.is_empty() && !matches_any_glob(path, &compiled_globs) {
                    continue;
                }

                searched_files += 1;

                // Read and search file content
                match fs::read_to_string(path).await {
                    Ok(content) => {
                        let mut line_num = 1;
                        for line in content.lines() {
                            if regex.is_match(line) {
                                let relative_path = path
                                    .strip_prefix(&config.root_dir)
                                    .unwrap_or(path)
                                    .to_string_lossy();

                                results.push(format!(
                                    "{}:{}:{}",
                                    relative_path,
                                    line_num,
                                    line.trim()
                                ));
                            }
                            line_num += 1;
                        }
                    }
                    Err(e) => {
                        // Skip files we can't read (binary files, etc.)
                        if results.len() < 3 {
                            // Only log first few errors
                            warn!("Failed to read file {:?}: {}", path, e);
                        }
                    }
                }

                // Limit to avoid overwhelming output
                if results.len() >= 100 {
                    break;
                }
            }
            Err(e) => {
                warn!("Error walking directory: {}", e);
            }
        }
    }

    let output = if results.is_empty() {
        format!(
            "Regex Search Results\n\
            Pattern: '{}'\n\
            Glob Filters: {:?}\n\
            Include Dependencies: {}\n\
            Include Documentation: {}\n\
            Files Searched: {}\n\
            \n\
            No matches found.\n\
            ",
            request.pattern, request.globs, include_deps, include_docs, searched_files
        )
    } else {
        let result_summary = if results.len() >= 100 {
            format!("Found {}+ matches (showing first 100):", results.len())
        } else {
            format!("Found {} matches:", results.len())
        };

        format!(
            "Regex Search Results\n\
            Pattern: '{}'\n\
            Glob Filters: {:?}\n\
            Include Dependencies: {}\n\
            Include Documentation: {}\n\
            Files Searched: {}\n\
            \n\
            {}\n\
            {}\n\
            ",
            request.pattern,
            request.globs,
            include_deps,
            include_docs,
            searched_files,
            result_summary,
            results.join("\n")
        )
    };

    Ok(output)
}

/// Check if a path matches any of the provided compiled glob patterns
#[allow(dead_code)] // Used by regex_search function
fn matches_any_glob(path: &Path, compiled_globs: &[glob::Pattern]) -> bool {
    let path_str = path.to_string_lossy();

    for pattern in compiled_globs {
        if pattern.matches(&path_str) {
            return true;
        }

        // Also check just the filename
        if let Some(filename) = path.file_name() {
            if pattern.matches(&filename.to_string_lossy()) {
                return true;
            }
        }
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile;

    #[tokio::test]
    async fn test_regex_search_basic_pattern() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");

        // Create a simple test file
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "pub fn add(a: i32, b: i32) -> i32 { a + b }")
            .expect("Failed to write test file");

        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        // Search for function definitions
        let request = RegexSearchRequest {
            pattern: r"pub fn \w+".to_string(),
            globs: None,
            include_deps: None,
            include_docs: None,
        };

        let result = regex_search(&config, request).await;
        assert!(result.is_ok(), "Regex search should succeed: {result:?}");

        let output = result.unwrap();

        // Should find function definitions in test file
        assert!(
            output.contains("pub fn"),
            "Should find function definitions"
        );
        assert!(output.contains("add"), "Should find the add function");
        assert!(
            output.contains("Files Searched:"),
            "Should show search stats"
        );
        assert!(output.contains("Found"), "Should show result count");
    }

    #[tokio::test]
    async fn test_regex_search_with_rust_glob() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");

        // Create test files
        let rust_file = temp_dir.path().join("test.rs");
        std::fs::write(&rust_file, "fn test() {}").expect("Failed to write rust file");

        let text_file = temp_dir.path().join("test.txt");
        std::fs::write(&text_file, "fn should_not_match").expect("Failed to write text file");

        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        // Search only in Rust files
        let request = RegexSearchRequest {
            pattern: "fn".to_string(),
            globs: Some(vec!["*.rs".to_string()]),
            include_deps: None,
            include_docs: None,
        };

        let result = regex_search(&config, request).await;
        assert!(result.is_ok());

        let output = result.unwrap();
        assert!(output.contains("Glob Filters: Some([\"*.rs\"])"));
        assert!(
            output.contains("fn"),
            "Should find function keywords in Rust files"
        );
    }

    #[tokio::test]
    async fn test_regex_search_no_matches() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");

        // Create a test file
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn test() {}").expect("Failed to write test file");

        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        // Search for something that doesn't exist
        let request = RegexSearchRequest {
            pattern: "ThisPatternDoesNotExistAnywhere".to_string(),
            globs: None,
            include_deps: None,
            include_docs: None,
        };

        let result = regex_search(&config, request).await;
        assert!(result.is_ok());

        let output = result.unwrap();
        assert!(
            output.contains("No matches found"),
            "Should report no matches"
        );
        assert!(
            output.contains("Files Searched:"),
            "Should still show files searched"
        );
    }

    #[tokio::test]
    async fn test_regex_search_invalid_pattern() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");
        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        // Use an invalid regex pattern
        let request = RegexSearchRequest {
            pattern: "[invalid".to_string(), // Missing closing bracket
            globs: None,
            include_deps: None,
            include_docs: None,
        };

        let result = regex_search(&config, request).await;
        assert!(result.is_err(), "Invalid regex should return error");

        let error = result.unwrap_err();
        assert!(
            error.contains("Invalid regex pattern"),
            "Should report regex error"
        );
    }

    #[tokio::test]
    async fn test_regex_search_invalid_glob() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");
        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        // Use an invalid glob pattern
        let request = RegexSearchRequest {
            pattern: "fn".to_string(),
            globs: Some(vec!["[invalid".to_string()]), // Invalid glob pattern
            include_deps: None,
            include_docs: None,
        };

        let result = regex_search(&config, request).await;
        assert!(result.is_err(), "Invalid glob should return error");

        let error = result.unwrap_err();
        assert!(
            error.contains("Invalid glob pattern"),
            "Should report glob error"
        );
    }

    #[tokio::test]
    async fn test_regex_search_specific_file_pattern() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp directory");

        // Create a math.rs file with mathematical operations
        let math_file = temp_dir.path().join("math.rs");
        std::fs::write(&math_file, "fn add(a: i32, b: i32) -> i32 { a + b }")
            .expect("Failed to write math file");

        let config = ServerConfig {
            root_dir: temp_dir.path().to_path_buf(),
        };

        // Search for mathematical operations specifically
        let request = RegexSearchRequest {
            pattern: r"a \+ b".to_string(),
            globs: Some(vec!["*.rs".to_string()]),
            include_deps: None,
            include_docs: None,
        };

        let result = regex_search(&config, request).await;
        assert!(result.is_ok());

        let output = result.unwrap();
        assert!(
            output.contains("a + b"),
            "Should find the mathematical operation"
        );
    }

    #[test]
    fn test_matches_any_glob() {
        let patterns = vec![
            glob::Pattern::new("*.rs").unwrap(),
            glob::Pattern::new("*.js").unwrap(),
        ];

        let rust_path = std::path::Path::new("src/main.rs");
        let js_path = std::path::Path::new("src/app.js");
        let py_path = std::path::Path::new("src/script.py");

        assert!(matches_any_glob(rust_path, &patterns));
        assert!(matches_any_glob(js_path, &patterns));
        assert!(!matches_any_glob(py_path, &patterns));
    }
}
